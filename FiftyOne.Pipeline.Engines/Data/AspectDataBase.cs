/* *********************************************************************
 * This Original Work is copyright of 51 Degrees Mobile Experts Limited.
 * Copyright 2020 51 Degrees Mobile Experts Limited, 5 Charlotte Close,
 * Caversham, Reading, Berkshire, United Kingdom RG4 7BY.
 *
 * This Original Work is licensed under the European Union Public Licence (EUPL) 
 * v.1.2 and is subject to its terms as set out below.
 *
 * If a copy of the EUPL was not distributed with this file, You can obtain
 * one at https://opensource.org/licenses/EUPL-1.2.
 *
 * The 'Compatible Licences' set out in the Appendix to the EUPL (as may be
 * amended by the European Commission) shall be deemed incompatible for
 * the purposes of the Work and the provisions of the compatibility
 * clause in Article 5 of the EUPL shall not apply.
 * 
 * If using the Work as, or as part of, a network application, by 
 * including the attribution notice(s) required under Article 5 of the EUPL
 * in the end user terms of the application under an appropriate heading, 
 * such notice(s) shall fulfill the requirements of that article.
 * ********************************************************************* */

using FiftyOne.Pipeline.Core.Data;
using FiftyOne.Pipeline.Core.FlowElements;
using FiftyOne.Pipeline.Engines.FlowElements;
using FiftyOne.Pipeline.Engines.Services;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

namespace FiftyOne.Pipeline.Engines.Data
{
    /// <summary>
    /// Base class for element data instances that are generated by an 
    /// <see cref="IAspectEngine"/>.
    /// Modifies the indexer from the <see cref="ElementDataBase"/>
    /// base class to use the <see cref="IMissingPropertyService"/> to 
    /// determine the reason that a requested key value is missing. 
    /// For example, if the user has excluded the property at the 
    /// configuration stage.
    /// </summary>
    public abstract class AspectDataBase : ElementDataBase, IAspectData
    {
        private List<Task> _processTasks = new List<Task>();

        private List<IAspectEngine> _engines;

        protected IMissingPropertyService MissingPropertyService { get; }

        protected ILogger<AspectDataBase> Logger { get; }

        /// <summary>
        /// The engine that generated this data instance.
        /// </summary>
        public IReadOnlyList<IAspectEngine> Engines
        {
            get
            {
                return _engines as IReadOnlyList<IAspectEngine>;
            }
        }

        /// <summary>
        /// If the engine is configured for lazy loading, this property 
        /// returns a task that will complete once the engine has finished
        /// processing.
        /// Otherwise, it will be null.
        /// </summary>
        public Task ProcessTask
        {
            get { return Task.WhenAll(_processTasks); }
        }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="logger">
        /// Used for logging
        /// </param>
        /// <param name="pipeline">
        /// The <see cref="IPipeline"/> instance this element data will
        /// be associated with.
        /// </param>
        /// <param name="engine">
        /// The <see cref="IAspectEngine"/> that created this instance
        /// </param>
        public AspectDataBase(
            ILogger<AspectDataBase> logger,
            IPipeline pipeline,
            IAspectEngine engine)
            : this(logger, pipeline, engine, null)
        { }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="logger">
        /// Used for logging
        /// </param>
        /// <param name="pipeline">
        /// The <see cref="IPipeline"/> instance this element data will
        /// be associated with.
        /// </param>
        /// <param name="engine">
        /// The <see cref="IAspectEngine"/> that created this instance
        /// </param>
        /// <param name="missingPropertyService">
        /// The <see cref="IMissingPropertyService"/> to use when a requested
        /// key cannot be found.
        /// </param>
        public AspectDataBase(
            ILogger<AspectDataBase> logger,
            IPipeline pipeline,
            IAspectEngine engine,
            IMissingPropertyService missingPropertyService)
            : base (logger, pipeline)
        {
            Logger = logger;
            _engines = new List<IAspectEngine>() { engine };
            MissingPropertyService = missingPropertyService;
        }

        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="logger">
        /// Used for logging
        /// </param>
        /// <param name="pipeline">
        /// The <see cref="IPipeline"/> instance this element data will
        /// be associated with.
        /// </param>
        /// <param name="engine">
        /// The <see cref="IAspectEngine"/> that created this instance
        /// </param>
        /// <param name="missingPropertyService">
        /// The <see cref="IMissingPropertyService"/> to use when a requested
        /// key cannot be found.
        /// </param>
        /// <param name="dictionary">
        /// The dictionary instance to use internally when storing data values.
        /// </param>
        public AspectDataBase(
            ILogger<AspectDataBase> logger,
            IPipeline pipeline,
            IAspectEngine engine,
            IMissingPropertyService missingPropertyService,
            IDictionary<string, object> dictionary)
            : base(logger, pipeline, dictionary)
        {
            Logger = logger;
            _engines = new List<IAspectEngine>() { engine };
            MissingPropertyService = missingPropertyService;
        }

        internal void AddEngine(IAspectEngine engine)
        {
            lock (Engines)
            {
                _engines.Add(engine);
            }
        }

        /// <summary>
        /// Add a process task to the lazy loading tasks for this 
        /// data instance.
        /// The property accessors will only complete once all such
        /// tasks have completed.
        /// </summary>
        /// <param name="processTask"></param>
        internal void AddProcessTask(Task processTask)
        {
            lock (_processTasks)
            {
                _processTasks.Add(processTask);
            }
        }

        /// <summary>
        /// get or set the specified value
        /// </summary>
        /// <param name="key">
        /// The key/name of the property to get or set.
        /// </param>
        /// <returns>
        /// The property value.
        /// </returns>
        /// <exception cref="PropertyMissingException">
        /// Thrown if there is no entry for the specified key.
        /// </exception>
        public override object this[string key]
        {
            get
            {
                return GetAs<object>(key);
            }
        }

        protected override T GetAs<T>(string key)
        {
            // Check parameter
            if (key == null) throw new ArgumentNullException("key");
            // Log the request
            if (Logger != null && Logger.IsEnabled(LogLevel.Debug))
            {
                Logger.LogDebug($"AspectData '{GetType().Name}'-'{GetHashCode()}' " +
                    $"property value requested for key '{key}'.");
            }

            // Attempt to get the property value.
            T propertyValue = default(T);
            var lazyLoadEngines = Engines.Where(e => e != null &&
                e.LazyLoadingConfiguration != null);
            bool lazyLoad = lazyLoadEngines.Any();
            CancellationTokenSource tokenSource = null;

            if (lazyLoad == true)
            {
                tokenSource = CancellationTokenSource.CreateLinkedTokenSource(
                    lazyLoadEngines
                    .Where(e => e.LazyLoadingConfiguration.CancellationToken.HasValue)
                    .Select(e => e.LazyLoadingConfiguration.CancellationToken.Value)
                    .ToArray());
            }

            IList<Exception> errors = null;
            // Only access the dictionary if:
            // 1. Engine is not configured for lazy loading.
            // 2. The process task has finished
            if (lazyLoad == false ||
                (errors = WaitOnAllProcessTasks(
                    lazyLoadEngines.Max(e => e.LazyLoadingConfiguration.PropertyTimeoutMs),
                    tokenSource.Token)).Count == 0)
            {
                if (TryGetValue(key, out propertyValue) == false &&
                    MissingPropertyService != null)
                {
                    // If there was no entry for the key then use the missing
                    // property service to find out why.
                    var missingReason = MissingPropertyService
                        .GetMissingPropertyReason(key, Engines);
                    if (Logger != null && Logger.IsEnabled(LogLevel.Warning))
                    {
                        Logger.LogWarning($"Property '{key}' missing from aspect " +
                        $"data '{GetType().Name}'-'{GetHashCode()}'. " +
                        $"{missingReason.Reason}");
                    }
                    throw new PropertyMissingException(missingReason.Reason,
                        key, missingReason.Description);
                }
            }
            else
            {
                Exception e = null;
                if (errors.Count == 1)
                {
                    e = errors[0];
                    if (e is OperationCanceledException) {
                        // The property is being lazy loaded but been canceled, so
                        // pass the exception up.
                        throw (OperationCanceledException)e;
                    }
                    else if (e is TimeoutException) {
                        // The property is being lazy loaded but has timed out
                        // or been canceled so throw the appropriate exception.
                        throw new TimeoutException(
                            $"Failed to retrieve property '" + key + "' " +
                            $"because the processing for engine(s) " +
                            $"{string.Join(", ", Engines.Select(i => i.GetType().Name).Distinct())}" +
                            $" took longer than the specified timeout.",
                            e);
                    }
                    else {
                        // The property is being lazy loaded but an error
                        // occurred in the engine's process method
                        throw new Exception(
                            $"Failed to retrieve property '" + key + "' " +
                            $"because processing threw an exception in engine(s) " +
                            $"{string.Join(", ", Engines.Select(i => i.GetType().Name).Distinct())}.",
                            e);
                    }
                }
                else
                {
                    // The property is being lazy loaded but multiple errors have
                    // occurred in the engine's process method
                    throw new AggregateException(
                        $"Failed to retrieve property '" + key + "' " +
                        $"because processing threw multiple exceptions in engine(s) " +
                        $"{string.Join(", ", Engines.Select(i => i.GetType().Name).Distinct())}.",
                        errors);
                }
            }
            
            return propertyValue;
        }

        /// <summary>
        /// Get the value associated with the specified key.
        /// Inheriting classes can override this method where they access
        /// data in different ways.
        /// </summary>
        /// <param name="key">
        /// The string key to retrieve the value for.
        /// </param>
        /// <param name="value">
        /// Will be populated with the value for the specified key.
        /// </param>
        /// <returns>
        /// True if the key is present in the data store, false if not.
        /// </returns>
        protected virtual bool TryGetValue<T>(string key, out T value)
        {
            object obj;
            if (AsDictionary().TryGetValue(key, out obj))
            {
                try
                {
                    value = (T)obj;
                }
                catch (InvalidCastException)
                {
                    throw new Exception(
                        $"Expected property '{key}' to be of " +
                        $"type '{typeof(T).Name}' but it is " +
                        $"'{obj.GetType().Name}'");
                }
                return true;
            }
            value = default(T);
            return false;
        }

        /// <summary>
        /// Waits for the completion of all process tasks which must complete
        /// before fetching a property value. Any exceptions which are thrown
        /// by a task are returned as a list.
        /// </summary>
        /// <param name="timeoutMillis">timeout for each task</param>
        /// <param name="token">cancellation token for the tasks</param>
        /// <returns>list of exceptions that occurred</returns>
        private IList<Exception> WaitOnAllProcessTasks(
            int timeoutMillis,
            CancellationToken token)
        {
            IList<Exception> errors = new List<Exception>();

            foreach (var task in _processTasks)
            {
                try
                {
                    if (task.Wait(timeoutMillis, token) == false)
                    {
                        if (token.IsCancellationRequested)
                        {
                            // The property is being lazy loaded but been canceled, so
                            // pass the exception up.
                            errors.Add(new OperationCanceledException());
                        }
                        else
                        {
                            // The property is being lazy loaded but has timed out
                            // or been canceled so throw the appropriate exception.
                            errors.Add(new TimeoutException());
                        }
                    }
                }
                catch (Exception e)
                {
                    errors.Add(e);
                }
            }
            return errors;
        }
    }
}
